# Розробка

Якщо ви недавно створили контракт за допомогою цього шаблону, вам, мабуть, знадобиться допомога щодо того, як зібрати і протестувати контракт, а також підготувати його до впровадження. Цей файл намагається надати короткий огляд, припускаючи, що ви вже встановили останню версію Rust (наприклад, 1.51.0+).

## Передумови

Перш ніж починати, переконайтеся, що у вас встановлено [rustup](https://rustup.rs/) разом з останньою версією `rustc` і `cargo`. Зараз ми тестуємо на 1.51.0+.

Також вам потрібно мати встановлений target `wasm32-unknown-unknown`.

Ви можете перевірити це за допомогою:

```sh
rustc --version
cargo --version
rustup target list --installed
# if wasm32 is not listed above, run this
rustup target add wasm32-unknown-unknown
```

## Компіляція і запуск тестів

Тепер, коли ви створили свій власний контракт, переконайтеся, що ви можете його скомпілювати і запустити перед тим, як робити які-небудь зміни. Перейдіть до репозиторію і зробіть:

```sh
# this will produce a wasm build in ./target/wasm32-unknown-unknown/release/YOUR_NAME_HERE.wasm
cargo wasm

# this runs unit tests with helpful backtraces
RUST_BACKTRACE=1 cargo unit-test

# auto-generate json schema
cargo schema
```

### Розуміння тестів

Основний код знаходиться в `src/contract.rs` , а модульні тести там виконуються на чистому rust, що робить їх дуже швидкими в виконанні і дає хороший вивід при збоях, особливо якщо ви робите `RUST_BACKTRACE=1 cargo unit-test`.

Ми вважаємо тестування критично важливим для всього, що пов'язано з блокчейном, і рекомендуємо завжди тримати
тести в актуальному стані.

## Генерація JSON схеми

Хоча Wasm колли  (`instantiate`, `execute`, `query`) приймають JSON, цього недостатньо, щоб його використовувати. Нам потрібно відкрити схему для очікуваних повідомлень клієнтам. Ви можете генерувати цю схему, викликаючи `cargo schema`, який виведе 4 файли в `./schema`, що відповідають 3 типам повідомлень, які приймає контракт, а також внутрішньому `State`.

Ці файли мають стандартний формат json-схеми, який має бути використаний різними клієнтськими інструментами, або для авто-генерації кодеків, або просто для перевірки вхідного json щодо визначеної схеми.

## Підготовка байткоду Wasm до роботи

Перед тим, як ми завантажимо його на ланцюг, нам потрібно забезпечити найменший можливий розмір виводу, оскільки він буде включений у тіло транзакції. Ми також хочемо мати відтворюваний процес збірки, щоб треті сторони могли перевірити, що завантажений код Wasm дійсно походить від заявленого коду rust.

Щоб вирішити обидві ці проблеми, ми створили `rust-optimizer`, образ docker для створення надзвичайно маленького виводу збірки у послідовний спосіб. Рекомендований спосіб його запуску такий:

```sh
docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.11
```

Або, якщо ви працюєте на машині arm64, вам слід використовувати образ docker, зібраний з arm64

```sh
docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer-arm64:0.12.11
```

Ми повинні монтувати код контракту до `/code` Ви можете використовувати абсолютний шлях замість `$(pwd)`, якщо ви не хочете спочатку переходити до директорії `cd`. Два інші томи корисні для прискорення. Монтування `/code/target`собливо корисне, щоб уникнути перезаписування docker вашими місцевими файлами розробки з правами root. Зверніть увагу, що кеш `/code/target` унікальний для кожного компілюваного контракту, щоб обмежити перешкоди, тоді як кеш реєстру є глобальним.

Це досить повільно в порівнянні з локальними компіляціями, особливо при першій компіляції даного контракту. Використання двох кешів томів дуже корисне для прискорення наступних компіляцій того ж контракту.


Це створює директорію `artifacts` з `PROJECT_NAME.wasm`, а також 
`checksums.txt`, що містить Sha256 хеш файлу wasm. Файл wasm компілюється детерміновано (будь-хто інший, хто запускає той же docker на тому ж самому зобов'язанні git, повинен отримати ідентичний файл з тим же Sha256 хешем). Він також обрізаний та мінімізований для завантаження на блокчейн (ми також зробимо gzip у процесі завантаження, щоб зробити його ще меншим).
